import heapq
from heapq import heappop
from typing import Tuple, List


class AvailabilityManager:
    """
    Class for managing the total availability of a
    given number of participants
    """

    def __init__(self, people: List[List[Tuple[int, int]]], meeting_length: int = 0):
        """
        Constructor for Availability manager

        Args:
            people (List[List[Tuple[int, int]]]): a list of list of tuples where each
                list of tuples is a persons availability and each tuple is a time
                frame in which that person is available

            meeting_length (int): the minimum time in which a meeting should span. if
                no time frame where all participants can attend is at least this long
                then no meeting time will be returned
        """
        self._times = {}
        self._raw = people
        self._graph = []
        self._size = len(people)
        self._meeting_length = meeting_length

        # by default compute the meeting times initially
        self.compute_availability()

    def make_availability_list(self) -> List[Tuple[int, int, int]]:
        """
        Creates a full table of each persons availability

        Returns:
            List[Tuple[int, int, int]]: a list of tuples where each
                value in the tuple has the format. unique person id,
                start time, and end time
        """
        graph = []
        current_person = 0
        for person in self._raw:
            for t0, t1 in person:
                heapq.heappush(graph, (t0, (current_person, t0, t1)))
            current_person += 1
        self._graph = graph
        return graph

    def add_availability(self, person: int, s0: int, s1: int) -> Tuple[int, int]:
        """
        Adds a person with a given time slot to
        the general availability list

        Args:
            person (int): a unique identifier for each person
            s0     (int): the start time of the persons availability
            s1     (int): the end time of the persons availability

        Returns:
            Tuple: the start and end time of the time period that
                   works for the given users
        """
        updated_times = {}

        if len(self._times) == 0:
            self._times[(s0, s1)] = {person}
            return

        if (s0, s1) in self._times:
            self._times[(s0, s1)] = {*self._times[(s0, s1)], person}
            return
        else:
            updated_times[(s0, s1)] = {person}

        for key, value in self._times.items():
            if (s0 >= key[0] and s0 <= key[1]) or (s1 <= key[1] and s1 >= key[0]):
                t0 = max(s0, key[0])
                t1 = min(s1, key[1])

                if t0 == t1:
                    updated_times[key] = value
                    continue

                new_list = {*value, person}
                updated_times[(t0, t1)] = new_list
            else:
                updated_times[key] = value

        self._times = updated_times

    def compute_availability(self):
        """
        Takes the individual availability of users and
        combines them into a list of potential meetup
        times
        """
        if len(self._graph) == 0:
            self.make_availability_list()

        while len(self._graph):
            person = heappop(self._graph)[1]
            self.add_availability(person[0], person[1], person[2])

    def get_all_times(self) -> List[Tuple[int, int, int]]:
        """
        Returns a full list of all time frames generated by the given users

        Returns:
            List[Tuple[int, int, int]]: a list of tuples where each tuple
                has the following format. number of unique members who can
                attend, start time, and end time.
        """
        times = []
        for key, value in self._times.items():
            times.append((len(value), key[0], key[1]))
        return times

    def get_valid_times(self) -> List[Tuple[int, int, int]]:
        """
        Returns only times that all participants can attend

        Returns:
            List[Tuple[int, int, int]]: a list of tuples where each tuple
                has the following format. number of unique members who can
                attend, start time, and end time.
        """
        all_times = self.get_all_times()
        # only meeting times that include all pariticpants are valid
        potential_times = list(filter(lambda v: v[0] == self._size, all_times))
        # only meeting times that are long enough to satisfy the meeting length
        # are valid times
        potential_times = list(
            filter(lambda v: (v[2] - v[1]) >= self._meeting_length, potential_times)
        )
        return potential_times


def find_meeting_time(
    *args: List[Tuple[int, int]], meeting_length: int = 0
) -> Tuple[int, int]:
    """
    Finds a meeting time with the given participants and given meeting
    parameters

    Args:
        meeting_length          (int): the length of the meeting
        *args (List[Tuple[int, int]]): a list of each persons
            available meeting times

    Returns:
        Tuple[int, int]: the start and stop time of the meeting
            that works for all participants or None if no meeting
            time can be generated
    """
    am = AvailabilityManager(list(args), meeting_length=meeting_length)
    potential_times = am.get_valid_times()

    if len(potential_times) == 0:
        return None

    # the meeting time is the first potential time
    meeting_time = (potential_times[0][1], potential_times[0][2])

    # no specified length to set meeting to
    if meeting_length == 0:
        return meeting_time

    # make sure meeting is of specified length
    return (meeting_time[0], meeting_time[0] + meeting_length)
